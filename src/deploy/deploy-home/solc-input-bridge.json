{
    "language": "Solidity",
    "sources": {
        "./contracts/Bridge.sol": {
            "content": "pragma solidity ^0.5.0;\n\nimport './openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\nimport \"./MessageHandler.sol\";\n\ncontract Bridge is MessageHandler {\n    event ExchangeRequest(uint96 value, uint32 nonce);\n\n    mapping(bytes32 => bool) usedExchangeRanges;\n\n    constructor(\n        uint16 threshold,\n        address[] memory validators,\n        address _tokenContract,\n        uint96[2] memory limits,\n        uint16 rangeSize,\n        bool closeEpoch\n    ) public {\n        require(validators.length > 0);\n        require(threshold <= validators.length);\n\n        tokenContract = IERC20(_tokenContract);\n\n        epoch = 0;\n        status = Status.KEYGEN;\n        nextEpoch = 1;\n\n        states[nextEpoch] = State({\n            validators : validators,\n            threshold : threshold,\n            rangeSize : rangeSize,\n            startBlock : 0,\n            endBlock : UPPER_BOUND,\n            nonce : UPPER_BOUND,\n            x : 0,\n            y : 0,\n            closeEpoch : closeEpoch\n        });\n\n        minTxLimit = limits[0];\n        maxTxLimit = limits[1];\n\n        emit NewEpoch(0, 1);\n    }\n\n    function exchange(uint96 value) public ready {\n        require(value >= minTxLimit && value >= 10 ** 10 && value <= maxTxLimit);\n\n        uint32 txRange = (uint32(block.number) - getStartBlock()) / uint32(getRangeSize());\n        if (!usedExchangeRanges[keccak256(abi.encodePacked(txRange, epoch))]) {\n            usedExchangeRanges[keccak256(abi.encodePacked(txRange, epoch))] = true;\n            states[epoch].nonce++;\n        }\n\n        tokenContract.transferFrom(msg.sender, address(this), value);\n        emit ExchangeRequest(value, getNonce());\n    }\n}\n"
        },
        "./contracts/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
            "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "./contracts/MessageHandler.sol": {
            "content": "pragma solidity ^0.5.0;\n\nimport \"./Government.sol\";\nimport \"./MessageDecoder.sol\";\n\ncontract MessageHandler is Government, MessageDecoder {\n    uint constant SIGNATURE_SIZE = 65;\n\n    mapping(bytes32 => bool) public handledMessages;\n\n    function applyMessage(bytes memory message, bytes memory signatures) public {\n        (bytes32 msgHash, uint16 msgEpoch) = checkSignedMessage(message, signatures);\n        handledMessages[msgHash] = true;\n\n        Action msgAction = Action(uint8(message[0]));\n\n        if (msgAction == Action.CONFIRM_KEYGEN || msgAction == Action.VOTE_CANCEL_KEYGEN) {\n            require(msgEpoch == nextEpoch, \"Incorrect message epoch\");\n        } else if (msgAction == Action.TRANSFER) {\n            require(msgEpoch <= epoch, \"Incorrect message epoch\");\n        } else {\n            require(msgEpoch == epoch, \"Incorrect message epoch\");\n        }\n\n        if (msgAction == Action.CONFIRM_KEYGEN) {\n            // [3,34] - x, [35,66] - y\n            require(message.length == 67, \"Incorrect message length\");\n            (uint x, uint y) = _decodeKeygen(message);\n            _confirmKeygen(x, y);\n        } else if (msgAction == Action.CONFIRM_FUNDS_TRANSFER) {\n            require(message.length == 3, \"Incorrect message length\");\n            _confirmFundsTransfer();\n        } else if (msgAction == Action.CONFIRM_CLOSE_EPOCH) {\n            require(message.length == 3, \"Incorrect message length\");\n            _confirmCloseEpoch();\n        } else if (msgAction == Action.VOTE_START_VOTING) {\n            require(message.length == 3, \"Incorrect message length\");\n            _startVoting();\n        } else if (msgAction == Action.VOTE_ADD_VALIDATOR) {\n            // [3,22] - address, [23,31] - extra data\n            require(message.length == 32, \"Incorrect message length\");\n            address validator = _decodeAddress(message);\n            _addValidator(validator);\n        } else if (msgAction == Action.VOTE_REMOVE_VALIDATOR) {\n            // [3,22] - address, [23,31] - extra data\n            require(message.length == 32, \"Incorrect message length\");\n            address validator = _decodeAddress(message);\n            _removeValidator(validator);\n        } else if (msgAction == Action.VOTE_CHANGE_THRESHOLD) {\n            // [3,4] - threshold, [5,31] - extra data\n            require(message.length == 32, \"Incorrect message length\");\n            uint16 threshold = _decodeUint16(message);\n            _changeThreshold(threshold);\n        } else if (msgAction == Action.VOTE_CHANGE_RANGE_SIZE) {\n            // [3,4] - rangeSize, [5,31] - extra data\n            require(message.length == 32, \"Incorrect message length\");\n            uint16 rangeSize = _decodeUint16(message);\n            _changeRangeSize(rangeSize);\n        } else if (msgAction == Action.VOTE_CHANGE_CLOSE_EPOCH) {\n            // [3] - closeEpoch, [4,31] - extra data\n            require(message.length == 32, \"Incorrect message length\");\n            bool closeEpoch = _decodeBoolean(message);\n            _changeCloseEpoch(closeEpoch);\n        } else if (msgAction == Action.VOTE_START_KEYGEN) {\n            require(message.length == 3, \"Incorrect message length\");\n            _startKeygen();\n        } else if (msgAction == Action.VOTE_CANCEL_KEYGEN) {\n            require(message.length == 3, \"Incorrect message length\");\n            _cancelKeygen();\n        } else if (msgAction == Action.TRANSFER) {\n            // [3,34] - txHash, [35,54] - address, [55,66] - value\n            require(message.length == 67, \"Incorrect message length\");\n            (address to, uint96 value) = _decodeTransfer(message);\n            _transfer(to, value);\n        } else {\n            revert(\"Unknown message action\");\n        }\n    }\n\n    function checkSignedMessage(bytes memory message, bytes memory signatures) view public returns (bytes32, uint16) {\n        require(signatures.length % SIGNATURE_SIZE == 0, \"Incorrect signatures length\");\n\n        bytes32 msgHash;\n        if (message.length == 3) {\n            msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n3\", message));\n        } else if (message.length == 32) {\n            msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n        } else if (message.length == 67) {\n            msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n67\", message));\n        } else {\n            revert(\"Incorrect message length\");\n        }\n        require(!handledMessages[msgHash], \"Tx was already handled\");\n\n        uint16 msgEpoch;\n        assembly {\n            msgEpoch := mload(add(message, 3))\n        }\n        require(msgEpoch <= nextEpoch, \"Invalid epoch number\");\n\n        uint signaturesNum = signatures.length / SIGNATURE_SIZE;\n        require(signaturesNum >= getThreshold(msgEpoch), \"Not enough signatures\");\n\n        address[] memory possibleValidators = getValidators(msgEpoch);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        for (uint i = 0; i < signaturesNum; i++) {\n            uint offset = i * SIGNATURE_SIZE;\n\n            assembly {\n                r := mload(add(add(signatures, 32), offset))\n                s := mload(add(add(signatures, 64), offset))\n                v := byte(0, mload(add(add(signatures, 96), offset)))\n            }\n\n            address signer = ecrecover(msgHash, v, r, s);\n            uint j;\n            for (j = 0; j < possibleValidators.length; j++) {\n                if (possibleValidators[j] == signer) {\n                    delete possibleValidators[j];\n                    break;\n                }\n            }\n            require(j != possibleValidators.length, \"Not a validator signature\");\n        }\n        return (msgHash, msgEpoch);\n    }\n}\n"
        },
        "./contracts/Government.sol": {
            "content": "pragma solidity ^0.5.0;\n\nimport \"./BasicBridge.sol\";\n\ncontract Government is BasicBridge {\n    enum Action {\n        CONFIRM_KEYGEN,\n        CONFIRM_FUNDS_TRANSFER,\n        CONFIRM_CLOSE_EPOCH,\n        VOTE_START_VOTING,\n        VOTE_ADD_VALIDATOR,\n        VOTE_REMOVE_VALIDATOR,\n        VOTE_CHANGE_THRESHOLD,\n        VOTE_CHANGE_RANGE_SIZE,\n        VOTE_CHANGE_CLOSE_EPOCH,\n        VOTE_START_KEYGEN,\n        VOTE_CANCEL_KEYGEN,\n        TRANSFER\n    }\n\n    function _confirmKeygen(uint x, uint y) internal keygen {\n        states[nextEpoch].x = x;\n        states[nextEpoch].y = y;\n        states[nextEpoch].nonce = UPPER_BOUND;\n        if (nextEpoch == 1) {\n            status = Status.READY;\n            states[nextEpoch].startBlock = uint32(block.number);\n            epoch = nextEpoch;\n            emit EpochStart(epoch, x, y);\n        }\n        else {\n            status = Status.FUNDS_TRANSFER;\n            emit NewFundsTransfer(epoch, nextEpoch);\n        }\n    }\n\n    function _confirmFundsTransfer() internal fundsTransfer {\n        require(epoch > 0, \"First epoch does not need funds transfer\");\n\n        status = Status.READY;\n        states[nextEpoch].startBlock = uint32(block.number);\n        epoch = nextEpoch;\n        emit EpochStart(epoch, getX(), getY());\n    }\n\n    function _confirmCloseEpoch() internal closingEpoch {\n        status = Status.VOTING;\n        emit EpochEnd(epoch);\n    }\n\n    function _startVoting() internal ready {\n        states[epoch].endBlock = uint32(block.number);\n        nextEpoch++;\n        states[nextEpoch].threshold = getThreshold();\n        states[nextEpoch].validators = getValidators();\n        states[nextEpoch].rangeSize = getRangeSize();\n        states[nextEpoch].closeEpoch = getCloseEpoch();\n\n        if (getCloseEpoch()) {\n            status = Status.CLOSING_EPOCH;\n            emit ForceSign();\n            emit EpochClose(epoch);\n        } else {\n            status = Status.VOTING;\n            emit ForceSign();\n            emit EpochEnd(epoch);\n        }\n    }\n\n    function _addValidator(address validator) internal voting {\n        require(getNextPartyId(validator) == 0, \"Already a validator\");\n\n        states[nextEpoch].validators.push(validator);\n    }\n\n    function _removeValidator(address validator) internal voting {\n        require(getNextPartyId(validator) != 0, \"Already not a validator\");\n\n        uint16 lastPartyId = getNextParties() - 1;\n        for (uint i = 0; i < lastPartyId; i++) {\n            if (states[nextEpoch].validators[i] == validator) {\n                states[nextEpoch].validators[i] = getNextValidators()[lastPartyId];\n                break;\n            }\n        }\n        delete states[nextEpoch].validators[lastPartyId];\n        states[nextEpoch].validators.length--;\n    }\n\n    function _changeThreshold(uint16 threshold) internal voting {\n        require(threshold > 0, \"Invalid threshold value\");\n\n        states[nextEpoch].threshold = threshold;\n    }\n\n    function _changeRangeSize(uint16 rangeSize) internal voting {\n        require(rangeSize > 0, \"Invalid range size\");\n\n        states[nextEpoch].rangeSize = rangeSize;\n    }\n\n    function _changeCloseEpoch(bool closeEpoch) internal voting {\n        states[nextEpoch].closeEpoch = closeEpoch;\n    }\n\n    function _startKeygen() internal voting {\n        require(getNextThreshold() <= getNextParties(), \"Invalid threshold number\");\n\n        status = Status.KEYGEN;\n\n        emit NewEpoch(epoch, nextEpoch);\n    }\n\n    function _cancelKeygen() internal keygen {\n        status = Status.VOTING;\n\n        emit NewEpochCancelled(nextEpoch);\n    }\n\n    function _transfer(address to, uint96 value) internal {\n        if (tokenContract.balanceOf(address(this)) >= value) {\n            tokenContract.transfer(to, value);\n        } else {\n            tokenContract.approve(to, value);\n        }\n    }\n}\n"
        },
        "./contracts/BasicBridge.sol": {
            "content": "pragma solidity ^0.5.0;\n\nimport './openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\n\ncontract BasicBridge {\n    uint32 constant UPPER_BOUND = 0xffffffff;\n\n    event EpochEnd(uint16 indexed epoch);\n    event EpochClose(uint16 indexed epoch);\n    event ForceSign();\n    event NewEpoch(uint16 indexed oldEpoch, uint16 indexed newEpoch);\n    event NewEpochCancelled(uint16 indexed epoch);\n    event NewFundsTransfer(uint16 indexed oldEpoch, uint16 indexed newEpoch);\n    event EpochStart(uint16 indexed epoch, uint x, uint y);\n\n    struct State {\n        address[] validators;\n        uint32 startBlock;\n        uint32 endBlock;\n        uint32 nonce;\n        uint16 threshold;\n        uint16 rangeSize;\n        bool closeEpoch;\n        uint x;\n        uint y;\n    }\n\n    enum Status {\n        READY, // bridge is in ready to perform operations\n        CLOSING_EPOCH, // generating transaction for blocking binance side of the bridge\n        VOTING, // voting for changing in next epoch, but still ready\n        KEYGEN, //keygen, can be cancelled\n        FUNDS_TRANSFER // funds transfer, cannot be cancelled\n    }\n\n    mapping(uint16 => State) public states;\n\n    Status public status;\n\n    uint16 public epoch;\n    uint16 public nextEpoch;\n\n    uint96 minTxLimit;\n    uint96 maxTxLimit;\n\n    IERC20 public tokenContract;\n\n    modifier ready {\n        require(status == Status.READY, \"Not in ready state\");\n        _;\n    }\n\n    modifier closingEpoch {\n        require(status == Status.CLOSING_EPOCH, \"Not in closing epoch state\");\n        _;\n    }\n\n    modifier voting {\n        require(status == Status.VOTING, \"Not in voting state\");\n        _;\n    }\n\n    modifier keygen {\n        require(status == Status.KEYGEN, \"Not in keygen state\");\n        _;\n    }\n\n    modifier fundsTransfer {\n        require(status == Status.FUNDS_TRANSFER, \"Not in funds transfer state\");\n        _;\n    }\n\n    function getParties() view public returns (uint16) {\n        return getParties(epoch);\n    }\n\n    function getNextParties() view public returns (uint16) {\n        return getParties(nextEpoch);\n    }\n\n    function getParties(uint16 _epoch) view public returns (uint16) {\n        return uint16(states[_epoch].validators.length);\n    }\n\n    function getThreshold() view public returns (uint16) {\n        return getThreshold(epoch);\n    }\n\n    function getNextThreshold() view public returns (uint16) {\n        return getThreshold(nextEpoch);\n    }\n\n    function getThreshold(uint16 _epoch) view public returns (uint16) {\n        return states[_epoch].threshold;\n    }\n\n    function getStartBlock() view public returns (uint32) {\n        return getStartBlock(epoch);\n    }\n\n    function getStartBlock(uint16 _epoch) view public returns (uint32) {\n        return states[_epoch].startBlock;\n    }\n\n    function getRangeSize() view public returns (uint16) {\n        return getRangeSize(epoch);\n    }\n\n    function getNextRangeSize() view public returns (uint16) {\n        return getRangeSize(nextEpoch);\n    }\n\n    function getRangeSize(uint16 _epoch) view public returns (uint16) {\n        return states[_epoch].rangeSize;\n    }\n\n    function getNonce() view public returns (uint32) {\n        return getNonce(epoch);\n    }\n\n    function getNonce(uint16 _epoch) view public returns (uint32) {\n        return states[_epoch].nonce;\n    }\n\n    function getX() view public returns (uint) {\n        return getX(epoch);\n    }\n\n    function getX(uint16 _epoch) view public returns (uint) {\n        return states[_epoch].x;\n    }\n\n    function getY() view public returns (uint) {\n        return getY(epoch);\n    }\n\n    function getY(uint16 _epoch) view public returns (uint) {\n        return states[_epoch].y;\n    }\n\n    function getCloseEpoch() view public returns (bool) {\n        return getCloseEpoch(epoch);\n    }\n\n    function getNextCloseEpoch() view public returns (bool) {\n        return getCloseEpoch(nextEpoch);\n    }\n\n    function getCloseEpoch(uint16 _epoch) view public returns (bool) {\n        return states[_epoch].closeEpoch;\n    }\n\n    function getPartyId() view public returns (uint16) {\n        address[] memory validators = getValidators();\n        for (uint i = 0; i < getParties(); i++) {\n            if (validators[i] == msg.sender)\n                return uint16(i + 1);\n        }\n        return 0;\n    }\n\n    function getNextPartyId(address a) view public returns (uint16) {\n        address[] memory validators = getNextValidators();\n        for (uint i = 0; i < getNextParties(); i++) {\n            if (validators[i] == a)\n                return uint16(i + 1);\n        }\n        return 0;\n    }\n\n    function getValidators() view public returns (address[] memory) {\n        return getValidators(epoch);\n    }\n\n    function getNextValidators() view public returns (address[] memory) {\n        return getValidators(nextEpoch);\n    }\n\n    function getValidators(uint16 _epoch) view public returns (address[] memory) {\n        return states[_epoch].validators;\n    }\n}\n"
        },
        "./contracts/MessageDecoder.sol": {
            "content": "pragma solidity ^0.5.0;\n\n\ncontract MessageDecoder {\n    // [0] - action type\n    // [1,2] - epoch\n    // [3..] - payload\n    function _decodeUint16(bytes memory message) pure internal returns (uint16 a) {\n        assembly {\n            a := mload(add(message, 5))\n        }\n    }\n\n    function _decodeBoolean(bytes memory message) pure internal returns (bool a) {\n        assembly {\n            a := and(mload(add(message, 4)), 1)\n        }\n    }\n\n    function _decodeAddress(bytes memory message) pure internal returns (address a) {\n        assembly {\n            a := mload(add(message, 23))\n        }\n    }\n\n    function _decodeKeygen(bytes memory message) pure internal returns (uint a, uint b) {\n        assembly {\n            a := mload(add(message, 35))\n            b := mload(add(message, 67))\n        }\n    }\n\n    function _decodeTransfer(bytes memory message) pure internal returns (address a, uint96 b) {\n        assembly {\n            a := mload(add(message, 55))\n            b := mload(add(message, 67))\n        }\n    }\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}